import pandas as pd

# Load current geocoded dataset (this already contains lat/long)
df_final = pd.read_csv('/Users/yangyungchyi/Documents/Spring 2025/MIS 462/geocoding data for next cycle.csv')

# Load the current cycle's data
df_current = pd.read_csv('/Users/yangyungchyi/Documents/Spring 2025/MIS 462/0420.csv')

# Clean up and ensure EntityID formats match
df_final['EntityID'] = df_final['EntityID'].astype(str).str.strip()
df_current['EntityID'] = df_current['EntityID'].astype(str).str.strip()

# Filter: only keep businesses in df_final that are still active in the current dataset
df_updated = df_final[df_final['EntityID'].isin(df_current['EntityID'])]

# Identify new records: present in df_current but not in df_final
existing_ids_set = set(df_final['EntityID'])
new_records = df_current[~df_current['EntityID'].isin(existing_ids_set)]

# Ensure new_records has all columns in df_final, including lat/long, even if missing
# Recalculate this AFTER any updates to df_final to preserve lat/long
columns_needed = df_final.columns
for col in columns_needed:
    if col not in new_records.columns:
        new_records[col] = ""

# Reorder new_records columns to match df_final
new_records = new_records[columns_needed]

# Merge old + new
updated_final = pd.concat([df_final, new_records], ignore_index=True)

# Final check before saving
print("Columns before saving:", updated_final.columns.tolist())

# Save the updated dataset
updated_final.to_csv('/Users/yangyungchyi/Documents/Spring 2025/MIS 462/0420_1.csv', index=False)
print("Updated dataset saved as '0420_1.csv'")
